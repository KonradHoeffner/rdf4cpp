#ifndef RDF4CPP_RDF_UTIL_BLANKNODEMANAGER_HPP
#define RDF4CPP_RDF_UTIL_BLANKNODEMANAGER_HPP

#include <rdf4cpp/rdf/bnode_management/IIdGenerator.hpp>
#include <rdf4cpp/rdf/bnode_management/NodeScope.hpp>
#include <rdf4cpp/rdf/bnode_management/reference_backends/factory/SkolemIRIFactory.hpp>
#include <rdf4cpp/rdf/bnode_management/reference_backends/factory/UnscopedBNodeFactory.hpp>
#include <rdf4cpp/rdf/bnode_management/reference_backends/generator/IncreasingIdGenerator.hpp>
#include <rdf4cpp/rdf/bnode_management/reference_backends/generator/RandomIdGenerator.hpp>

#include <memory>
#include <string>
#include <string_view>

namespace rdf4cpp::rdf::util {

/**
 * A standalone generator to generate nodes using a given backend.
 * Nodes generated by this generator are not remembered in any way
 * and new generate_node/generate_id calls generate new nodes on every invocation
 * (* this is not guaranteed but it is unlikely for this statement to become false).
 *
 * Generating nodes is always thread safe.
 */
struct NodeGenerator {
    using NodeStorage = storage::node::NodeStorage;
private:
    std::unique_ptr<IIdGenerator> impl;
    explicit NodeGenerator(std::unique_ptr<IIdGenerator> &&impl);
public:
    NodeGenerator(NodeGenerator &&other) noexcept = default;

    /**
     * Fetch the default generator. It uses the reference_backends/generator/RandomIdGenerator to generate ids.
     * @return a reference to the default generator.
     */
    [[nodiscard]] static NodeGenerator &default_instance();

    /**
     * Creates a generator from a given generator backend.
     * @param backend the backend to use
     * @return a NodeGenerator using the given backend
     */
    [[nodiscard]] static NodeGenerator with_backend(std::unique_ptr<IIdGenerator> backend);

    /**
     * Creates a generator from a backend type a constructor arguments
     * to construct the given backend type.
     *
     * @tparam GeneratorBackend type of the backend to use
     * @param args arguments to pass to the constructor of GeneratorBackend to create it
     * @return a NodeGenerator using the newly constructed backend
     */
    template<typename GeneratorBackend, typename ...Args> requires std::derived_from<GeneratorBackend, IIdGenerator>
    static NodeGenerator with_backend(Args &&...args) {
        return NodeGenerator{std::make_unique<GeneratorBackend>(std::forward<Args>(args)...)};
    }

    /**
     * Generates a new id as std::string using the backend.
     * @return a new id
     */
    [[nodiscard]] std::string generate_id();

    /**
     * Generates a new node by first generating a new id using the backend, and then
     * wrapping the id into a node by using the given factory.
     *
     * @param factory factory to wrap the generated id into a node
     * @param node_storage the node storage in which the new node is placed
     * @return the generated node
     */
    [[nodiscard]] Node generate_node(INodeFactory &factory = UnscopedBNodeFactory::default_instance(), NodeStorage &node_storage = NodeStorage::default_instance());

    /**
     * Creates a new NodeScope using this generator and the default NodeScope backend (i.e. reference_backends/scope/ReferenceBNodeScope).
     * @return a new scope using the stated backends
     */
    NodeScope scope();

    /**
     * Creates a new NodeScope using this generator and an instance of Backend as the NodeScope.
     * The NodeScope backend instance is constructed using the provided constructor arguments.
     *
     * @tparam Backend type of NodeScope backend to use
     * @param args constructor arguments for Backend to construct an instance
     * @return a new scope using the stated backends
     */
    template<typename Backend, typename ...Args> requires std::derived_from<Backend, INodeScope>
    NodeScope scope(Args &&...args) {
        return NodeScope{this->impl.get(), SharedPtr<Backend>::make(std::forward<Args>(args)...)};
    }
};

}  //namespace rdf4cpp::rdf::util

#endif  //RDF4CPP_RDF_UTIL_BLANKNODEMANAGER_HPP
